<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Laravel on 二次元の技术宅</title><link>/tags/laravel/</link><description>Recent content in Laravel on 二次元の技术宅</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 18 May 2024 09:36:41 +0800</lastBuildDate><atom:link href="/tags/laravel/index.xml" rel="self" type="application/rss+xml"/><item><title>解决容器内运行laravel定时任务导致大量进程的问题</title><link>/post/2024/05/crond-in-container-schdule-zombies/</link><pubDate>Sat, 18 May 2024 09:36:41 +0800</pubDate><guid>/post/2024/05/crond-in-container-schdule-zombies/</guid><description>&lt;p>起因是内网服务器每隔一阵就会失去网络连接，而且外接键鼠也会没有反应。那必定是什么程序占用了大量系统资源，想想只有近期部署的horizon和schedule服务可能出现这个问题。直觉一位&lt;code>php artisan schedule:run&lt;/code>运行结束后就退出了，没有副作用。我便关注起horizon服务了，这反而让我踩了坑，因为僵尸进程恰恰就是schedule服务间接造成的。还是要经常打破思维惯性，常规之外总有意外。&lt;/p>
&lt;p>在此说明下schedule服务的部署方式，方便大家与自身场景比对。laravel schedule中定义的任务都是&lt;code>runInBackground&lt;/code>模式。schedule服务是以容器内部的定时来运行的，即&lt;code>crond&lt;/code>是容器的init进程（pid 0），它根据我定义的crontabs文件，进一步调用schedule命令。直接造成僵尸进程的“罪魁祸首”便是有些无辜的crond了。我仿佛听到它一脸无辜地申辩：我不知道啊！言归正传，下面记录了僵尸进程的发现和解决方法。&lt;/p></description></item><item><title>折腾laravel总结</title><link>/post/2017/04/laravel-learning/</link><pubDate>Thu, 27 Apr 2017 14:17:52 +0800</pubDate><guid>/post/2017/04/laravel-learning/</guid><description>&lt;p>学习laravel遇到的一些坑，备忘。&lt;/p></description></item></channel></rss>